{"title":"MySQL","slug":"MySQL","date":"2023-07-28T01:21:15.000Z","updated":"2025-03-21T02:29:01.741Z","comments":true,"path":"api/articles/MySQL.json","excerpt":null,"covers":["/2023/07/28/MySQL/1.png","https://img-blog.csdnimg.cn/img_convert/9b7dc733fa94a2f1db7956baf0b9ade7.png"],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p><strong>附录:</strong></p>\n<ul>\n<li><strong>DQL</strong>(Dimensional Query Language):数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：SELECT &lt;字段名表&gt;FROM &lt;表或视图名&gt;WHERE &lt;查询条件&gt;</li>\n<li><strong>DML</strong>(data manipulation language)：DML用来对数据库里的数据进行操作的语言,例如UPDATE、INSERT、DELETE</li>\n<li><strong>DDL</strong>(data definition language)： DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用,主要的命令有CREATE、ALTER、DROP、TRUNCATE等 </li>\n<li><strong>DCL</strong>(Data Control Language)：DCL是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL</li>\n</ul>\n<h2><span id=\"1-innodb存储引擎\">1. Innodb存储引擎</span></h2><h3><span id=\"11架构\"><strong>1.1架构</strong></span></h3><p>MySQL5.5版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用广泛。下图是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p>\n<img src=\"/2023/07/28/MySQL/1.png\" class width=\"1\">\n\n<ul>\n<li>内存结构</li>\n</ul>\n<p>​\t①Buffer pool：在执行增删改查操作时，先操作缓冲池中的数据，(缓冲池没有数据，再去磁盘加载并缓存在缓冲池中)，然后再以一定</p>\n<p>​\t的频率刷新到磁盘中，减少磁盘IO，加快处理速度。</p>\n<p>​\t缓冲池以page为单位，底层采用链表数据结构管理page。</p>\n<p>​\t②change buffer：更改缓冲区（针对非唯一的二级索引页）。在执行DML语句时，如果数据不存在于Buffer pool，就把数据从磁盘加载</p>\n<p>​\t到更改缓冲区，在更改缓冲区完成操作后，以一定的频率刷新到Buffer pool，再由Buffer pool刷新到磁盘。二级索引的DML操作是主键</p>\n<p>​\t乱序插入的，频繁乱序的磁盘IO会大大减低处理速度，这就是change buffer存在的意义。</p>\n<p>​\t③Adaptive Hash Index：自适应hash索引，用于优化buffer pool数据的查询。</p>\n<p>​\t④log buffer：日志缓冲区。用来保存要写入磁盘的log日志（redo log、undo log），默认为16M，日志缓冲区的日志会定期刷新到磁</p>\n<p>​\t盘。可以通过增加日志缓冲区的大小来减少磁盘IO。</p>\n<p>​\t<strong>参数：</strong></p>\n<p>​\t<code>innodb_log_buffer_size</code>：缓冲区大小 </p>\n<p>​\t<code>innodb_flush_log_at_trx_commit</code>：刷新日志时机（0：每次事务提交时刷新到磁盘；1：每秒刷新到磁盘；2：日志在每次事务提交后\t写入，并每秒刷新到磁盘）。</p>\n<ul>\n<li>磁盘结构</li>\n</ul>\n<p>​\t①system tablespace：系统表空间是更改缓冲区的存储区域。</p>\n<p>​\t②file-per-table tablespace：每个表的文件表空间。每一张表都会生成一个独立的表空间文件。</p>\n<p>​\t③general tablespaces：通用表空间，默认不存在，但可以手动创建，手动指定关联。</p>\n<p>​\t④doublewrite buffer files:双写缓冲区。InnoDB引擎将数据页从buffer pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系</p>\n<p>​\t统异常时恢复数据。</p>\n<p>​\t⑤undo tablespace：撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（大小默认16M），用于存储undo log。</p>\n<p>​\t⑥temporary tablespaces：临时表空间，用于存放临时表等数据。</p>\n<p>​\t⑦redo log：重做日志，用来实现事务的持久性。当事务提交之后，会把所有修改信息都存到该日志中，用于在刷新脏页到磁盘发生错</p>\n<p>​\t误时，进行数据恢复使用。</p>\n<h3><span id=\"12-事务原理\">1.2 事务原理</span></h3><ul>\n<li><strong>redo log</strong></li>\n</ul>\n<p>​\t重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p>\n<ul>\n<li><strong>undo log</strong></li>\n</ul>\n<p>​\t回滚日志,用于记录数据被修改前的信息,作用包含两个:提供回滚和MVCC(多版本并发控制)</p>\n<p>原子性：undo log</p>\n<p>持久性：redo log</p>\n<p>一致性：undo log +redo log</p>\n<p>隔离性：锁+MVCC</p>\n<h3><span id=\"13-mvcc\">1.3 MVCC</span></h3><h2><span id=\"2b树\">2.B+树</span></h2><p><strong>索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。</strong> </p>\n<p>索引在mysql数据库中分三类： </p>\n<ul>\n<li>B+树索引</li>\n<li>Hash索引</li>\n<li>全文索引</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9b7dc733fa94a2f1db7956baf0b9ade7.png\" alt=\"img\"></p>\n<p>根据上图我们来看下B+树和B树有什么不同。 </p>\n<ol>\n<li><p>B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。之所以这么做是因为在数据库中页的大小是固定的，innodb中页的默认大小是16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。另外，B+树的阶数是等于键值的数量的，如果我们的B+树一个节点可以存储1000个键值，那么3层B+树可以存储1000×1000×1000&#x3D;10亿个数据。一般根节点是常驻内存的，所以一般我们查找10亿数据，只需要2次磁盘IO。 </p>\n</li>\n<li><p>因为B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。</p>\n</li>\n</ol>\n<p>有心的读者可能还发现上图B+树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。</p>\n<p>其实上面的B树我们也可以对各个节点加上链表。其实这些不是它们之前的区别，是因为在mysql的innodb存储引擎中，索引就是这样存储的。也就是<strong>说上图中的B+树索引就是innodb中B+树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。</strong></p>\n<p>通过上图可以看到，在innodb中，我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。</p>\n<blockquote>\n<p>MyISAM中的B+树索引实现与innodb中的略有不同。在MyISAM中，B+树索引的叶子节点并不存储数据，而是存储数据的文件地址。</p>\n</blockquote>\n<h2><span id=\"3优化案例\">3.优化案例</span></h2><ol>\n<li>mysql嵌套子查询效率确实比较低， 可以将其优化成连接查询</li>\n<li>学会分析sql执行计划，mysql会对sql进行优化，所以分析执行计划很重要</li>\n<li>内连接查询的时候，不管谁是左表右表，执行结果都一样。因为mysql会自动把小结果集的表选为驱动表（ 驱动表无论如何都会被全表扫描 ），大结果集的表选为被驱动表，被驱动表上的索引才生效。所以一般都是先执行where过滤，用到大表中的索引，然后再把小表和过滤后的大表关联到一起</li>\n<li>简单来说就是小表驱动大表，大表索引过滤</li>\n</ol>\n<h2><span id=\"4乐观锁悲观锁\">4.乐观锁悲观锁</span></h2><blockquote>\n<p>**悲观锁：**又称排他锁，具有很强的排他性，在数据处理过程中会将数据出于锁定状态。</p>\n<p>悲观锁的实现往往是依靠数据库提供的锁机制。</p>\n<p>关系数据库锁机制有： 行级锁，标级锁，读锁，写锁，都是在操作之前先上锁。 悲观锁的隔离级别可以看做可重复读。</p>\n</blockquote>\n<blockquote>\n<p><strong>乐观锁:</strong>\t相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制，大多是基于版本号（ Version ）记录机制实现，而不需要借助数据库的锁机制。<br>乐观锁的本质不是锁，其隔离级别可以看作为读未提交</p>\n</blockquote>\n<p><strong>悲观锁的优缺点：</strong></p>\n<p>悲观锁的优点是能避免冲突的发生。</p>\n<p>悲观锁的缺点是开销较大，而且加锁时间较长，对于并发的访问性支持不好。</p>\n<p><strong>乐观锁的优缺点：</strong></p>\n<p>乐观锁的优点是避免了长事务中的数据库加锁解锁开销，大大提升了大并发量下的系统整体性能表现。</p>\n<p>乐观锁的缺点是只能在提交数据时才发现业务事务将要失败，如果系统的冲突非常的多，而且一旦冲突就要因为重新计算提交而造成较大的代价的话，乐观锁也会带来很大的问题。</p>\n<p><strong>乐观锁与悲观锁的选择：</strong></p>\n<p>乐观锁适用多读场景。</p>\n<p>悲观锁适用于多写的场景，避免了产生冲突。</p>\n<h2><span id=\"5日志\">5.日志</span></h2><p>MySQL三大日志包括：undolog，redo log，binlog，它们分别有以下作用：</p>\n<p>undolog：是<strong>Innodb存储引擎</strong>生成的日志。用于事务的<strong>回滚和MVCC</strong>，保证了事务的<strong>原子性</strong>。</p>\n<p>redo log：是<strong>Innodb存储引擎</strong>生成的日志。用于<strong>崩溃后修复</strong>数据，保证了事务的<strong>持久性</strong>。</p>\n<p>binlog：是<strong>Server层</strong>生成的日志。用于<strong>备份数据</strong>，<strong>集群</strong>等。</p>\n<p><a href=\"https://blog.csdn.net/weixin_46345400/article/details/128732002\">MySQL三大日志_#HashMap#的博客-CSDN博客</a></p>\n<h2><span id=\"6主从同步\">6.主从同步</span></h2><h2><span id=\"7集群\">7.集群</span></h2>","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<p><strong>附录:</strong></p>\n<ul>\n<li><strong>DQL</strong>(Dimensional Query Language):数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：SELECT &lt;字段名表&gt;FROM &lt;表或视图名&gt;WHERE &lt;查询条件&gt;</li>\n<li><strong>DML</strong>(data manipulation language)：DML用来对数据库里的数据进行操作的语言,例如UPDATE、INSERT、DELETE</li>\n<li><strong>DDL</strong>(data definition language)： DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用,主要的命令有CREATE、ALTER、DROP、TRUNCATE等 </li>\n<li><strong>DCL</strong>(Data Control Language)：DCL是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL</li>\n</ul>\n<h2 id=\"1-Innodb存储引擎\"><a href=\"#1-Innodb存储引擎\" class=\"headerlink\" title=\"1. Innodb存储引擎\"></a>1. Innodb存储引擎</h2><h3 id=\"1-1架构\"><a href=\"#1-1架构\" class=\"headerlink\" title=\"1.1架构\"></a><strong>1.1架构</strong></h3><p>MySQL5.5版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用广泛。下图是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p>\n<img src=\"/2023/07/28/MySQL/1.png\" class=\"\" width=\"1\">\n\n<ul>\n<li>内存结构</li>\n</ul>\n<p>​\t①Buffer pool：在执行增删改查操作时，先操作缓冲池中的数据，(缓冲池没有数据，再去磁盘加载并缓存在缓冲池中)，然后再以一定</p>\n<p>​\t的频率刷新到磁盘中，减少磁盘IO，加快处理速度。</p>\n<p>​\t缓冲池以page为单位，底层采用链表数据结构管理page。</p>\n<p>​\t②change buffer：更改缓冲区（针对非唯一的二级索引页）。在执行DML语句时，如果数据不存在于Buffer pool，就把数据从磁盘加载</p>\n<p>​\t到更改缓冲区，在更改缓冲区完成操作后，以一定的频率刷新到Buffer pool，再由Buffer pool刷新到磁盘。二级索引的DML操作是主键</p>\n<p>​\t乱序插入的，频繁乱序的磁盘IO会大大减低处理速度，这就是change buffer存在的意义。</p>\n<p>​\t③Adaptive Hash Index：自适应hash索引，用于优化buffer pool数据的查询。</p>\n<p>​\t④log buffer：日志缓冲区。用来保存要写入磁盘的log日志（redo log、undo log），默认为16M，日志缓冲区的日志会定期刷新到磁</p>\n<p>​\t盘。可以通过增加日志缓冲区的大小来减少磁盘IO。</p>\n<p>​\t<strong>参数：</strong></p>\n<p>​\t<code>innodb_log_buffer_size</code>：缓冲区大小 </p>\n<p>​\t<code>innodb_flush_log_at_trx_commit</code>：刷新日志时机（0：每次事务提交时刷新到磁盘；1：每秒刷新到磁盘；2：日志在每次事务提交后\t写入，并每秒刷新到磁盘）。</p>\n<ul>\n<li>磁盘结构</li>\n</ul>\n<p>​\t①system tablespace：系统表空间是更改缓冲区的存储区域。</p>\n<p>​\t②file-per-table tablespace：每个表的文件表空间。每一张表都会生成一个独立的表空间文件。</p>\n<p>​\t③general tablespaces：通用表空间，默认不存在，但可以手动创建，手动指定关联。</p>\n<p>​\t④doublewrite buffer files:双写缓冲区。InnoDB引擎将数据页从buffer pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系</p>\n<p>​\t统异常时恢复数据。</p>\n<p>​\t⑤undo tablespace：撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（大小默认16M），用于存储undo log。</p>\n<p>​\t⑥temporary tablespaces：临时表空间，用于存放临时表等数据。</p>\n<p>​\t⑦redo log：重做日志，用来实现事务的持久性。当事务提交之后，会把所有修改信息都存到该日志中，用于在刷新脏页到磁盘发生错</p>\n<p>​\t误时，进行数据恢复使用。</p>\n<h3 id=\"1-2-事务原理\"><a href=\"#1-2-事务原理\" class=\"headerlink\" title=\"1.2 事务原理\"></a>1.2 事务原理</h3><ul>\n<li><strong>redo log</strong></li>\n</ul>\n<p>​\t重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p>\n<ul>\n<li><strong>undo log</strong></li>\n</ul>\n<p>​\t回滚日志,用于记录数据被修改前的信息,作用包含两个:提供回滚和MVCC(多版本并发控制)</p>\n<p>原子性：undo log</p>\n<p>持久性：redo log</p>\n<p>一致性：undo log +redo log</p>\n<p>隔离性：锁+MVCC</p>\n<h3 id=\"1-3-MVCC\"><a href=\"#1-3-MVCC\" class=\"headerlink\" title=\"1.3 MVCC\"></a>1.3 MVCC</h3><h2 id=\"2-B-树\"><a href=\"#2-B-树\" class=\"headerlink\" title=\"2.B+树\"></a>2.B+树</h2><p><strong>索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。</strong> </p>\n<p>索引在mysql数据库中分三类： </p>\n<ul>\n<li>B+树索引</li>\n<li>Hash索引</li>\n<li>全文索引</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9b7dc733fa94a2f1db7956baf0b9ade7.png\" alt=\"img\"></p>\n<p>根据上图我们来看下B+树和B树有什么不同。 </p>\n<ol>\n<li><p>B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。之所以这么做是因为在数据库中页的大小是固定的，innodb中页的默认大小是16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。另外，B+树的阶数是等于键值的数量的，如果我们的B+树一个节点可以存储1000个键值，那么3层B+树可以存储1000×1000×1000&#x3D;10亿个数据。一般根节点是常驻内存的，所以一般我们查找10亿数据，只需要2次磁盘IO。 </p>\n</li>\n<li><p>因为B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。</p>\n</li>\n</ol>\n<p>有心的读者可能还发现上图B+树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。</p>\n<p>其实上面的B树我们也可以对各个节点加上链表。其实这些不是它们之前的区别，是因为在mysql的innodb存储引擎中，索引就是这样存储的。也就是<strong>说上图中的B+树索引就是innodb中B+树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。</strong></p>\n<p>通过上图可以看到，在innodb中，我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。</p>\n<blockquote>\n<p>MyISAM中的B+树索引实现与innodb中的略有不同。在MyISAM中，B+树索引的叶子节点并不存储数据，而是存储数据的文件地址。</p>\n</blockquote>\n<h2 id=\"3-优化案例\"><a href=\"#3-优化案例\" class=\"headerlink\" title=\"3.优化案例\"></a>3.优化案例</h2><ol>\n<li>mysql嵌套子查询效率确实比较低， 可以将其优化成连接查询</li>\n<li>学会分析sql执行计划，mysql会对sql进行优化，所以分析执行计划很重要</li>\n<li>内连接查询的时候，不管谁是左表右表，执行结果都一样。因为mysql会自动把小结果集的表选为驱动表（ 驱动表无论如何都会被全表扫描 ），大结果集的表选为被驱动表，被驱动表上的索引才生效。所以一般都是先执行where过滤，用到大表中的索引，然后再把小表和过滤后的大表关联到一起</li>\n<li>简单来说就是小表驱动大表，大表索引过滤</li>\n</ol>\n<h2 id=\"4-乐观锁悲观锁\"><a href=\"#4-乐观锁悲观锁\" class=\"headerlink\" title=\"4.乐观锁悲观锁\"></a>4.乐观锁悲观锁</h2><blockquote>\n<p>**悲观锁：**又称排他锁，具有很强的排他性，在数据处理过程中会将数据出于锁定状态。</p>\n<p>悲观锁的实现往往是依靠数据库提供的锁机制。</p>\n<p>关系数据库锁机制有： 行级锁，标级锁，读锁，写锁，都是在操作之前先上锁。 悲观锁的隔离级别可以看做可重复读。</p>\n</blockquote>\n<blockquote>\n<p><strong>乐观锁:</strong>\t相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制，大多是基于版本号（ Version ）记录机制实现，而不需要借助数据库的锁机制。<br>乐观锁的本质不是锁，其隔离级别可以看作为读未提交</p>\n</blockquote>\n<p><strong>悲观锁的优缺点：</strong></p>\n<p>悲观锁的优点是能避免冲突的发生。</p>\n<p>悲观锁的缺点是开销较大，而且加锁时间较长，对于并发的访问性支持不好。</p>\n<p><strong>乐观锁的优缺点：</strong></p>\n<p>乐观锁的优点是避免了长事务中的数据库加锁解锁开销，大大提升了大并发量下的系统整体性能表现。</p>\n<p>乐观锁的缺点是只能在提交数据时才发现业务事务将要失败，如果系统的冲突非常的多，而且一旦冲突就要因为重新计算提交而造成较大的代价的话，乐观锁也会带来很大的问题。</p>\n<p><strong>乐观锁与悲观锁的选择：</strong></p>\n<p>乐观锁适用多读场景。</p>\n<p>悲观锁适用于多写的场景，避免了产生冲突。</p>\n<h2 id=\"5-日志\"><a href=\"#5-日志\" class=\"headerlink\" title=\"5.日志\"></a>5.日志</h2><p>MySQL三大日志包括：undolog，redo log，binlog，它们分别有以下作用：</p>\n<p>undolog：是<strong>Innodb存储引擎</strong>生成的日志。用于事务的<strong>回滚和MVCC</strong>，保证了事务的<strong>原子性</strong>。</p>\n<p>redo log：是<strong>Innodb存储引擎</strong>生成的日志。用于<strong>崩溃后修复</strong>数据，保证了事务的<strong>持久性</strong>。</p>\n<p>binlog：是<strong>Server层</strong>生成的日志。用于<strong>备份数据</strong>，<strong>集群</strong>等。</p>\n<p><a href=\"https://blog.csdn.net/weixin_46345400/article/details/128732002\">MySQL三大日志_#HashMap#的博客-CSDN博客</a></p>\n<h2 id=\"6-主从同步\"><a href=\"#6-主从同步\" class=\"headerlink\" title=\"6.主从同步\"></a>6.主从同步</h2><h2 id=\"7-集群\"><a href=\"#7-集群\" class=\"headerlink\" title=\"7.集群\"></a>7.集群</h2>","categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"MySQL","path":"api/tags/MySQL.json"}]}